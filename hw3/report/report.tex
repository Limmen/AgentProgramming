\documentclass[a4paper, 11pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{lmodern}
\usepackage{graphicx}
\graphicspath{ {./images/} }
\usepackage[english]{babel} 
\usepackage{natbib}
\usepackage{cite}
\usepackage[parfill]{parskip}
\usepackage{enumerate}
\usepackage{float}%for image positions
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\usepackage{amsthm}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{invariant}[theorem]{Invariant}
\newtheorem{breakpoint}[theorem]{Breakpoint}
\newtheorem{problem}{Problem}
\newtheorem{definition}{Definition} 
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{pifont}
\usepackage{multirow,array}
\usepackage{centernot}
\usepackage{comment} % enables the use of multi-line comments (\ifx \fi) 
\usepackage{lipsum} %This package just generates Lorem Ipsum filler text. 
\usepackage{fullpage} % changes the margin
\usepackage{soul}
\usepackage{algorithm}
\usepackage{algpseudocode}
\begin{document}
\noindent
\large\textbf{Homework 3} \hfill \textbf{Kim Hammar} \\
\normalsize ID2209 \hfill Due Date: 29 November 2016 \\
Distributed Artifical Intelligence and Intelligent Agents \hfill \\

\section*{Problem Statement}
Implement the following using the JAVA Agent Development Framework (JADE) \citep{jade}
\begin{description}
\item[Task \#1] M.A.S for solving the N-Queens problem where agents coordinate with each other to choose the right positions.
\item[Task \#2] M.A.S with mobile agents that can perform dutch auction in different places. Mobility means in this context that agents have the possibility to move between containers.
\end{description}

\subsection*{N-Queens}
\subsubsection*{Agent Design}
The M.A.S for task \#1 consists of only one agent-type, the \texttt{QueenAgent}. The \texttt{QueenAgent} is designed to be reactive and receiving messages from other agents, upon receipt of a message from another queen, the agent will compute a ``safe'' position on the board according to the following algorithm (randomness is used to be able to find different solutions to the same puzzle):
\begin{algorithm}[H]
\caption{QueenAgent algorithm for selecting a slot on the board}
\label{queen_algo}
\begin{algorithmic}[H]
\Require 
\State $B$ \Comment{Board}
\State $id$ \Comment{Id of the agent}
\State $T$ \Comment{Safe positions on the current board that have already been tried}
\Ensure 
\State $p$ is the selected safe position which have not previously been tried. If no safe position is found, $p = -1$.
\Procedure{SELECT\_SAFES\_SLOT}{B,id,T}
\State
\State $R$  $\leftarrow$ \texttt{Shuffle($B[id]$)} \Comment{random shuffle the row of possible positions}
\State $p \leftarrow -1$
\For{$r \in R$}
\State $i \leftarrow $\texttt{indexOf(r)}
\If{\texttt{safeDiagonally($i$)} $\land$ \texttt{safeVertically($i$)} $\land \neg i \in T$}
\State $p \leftarrow i$
\State \texttt{break}
\EndIf
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
\subsubsection*{Society Design}
The \texttt{QueenAgent}'s will take turn selecting slot on the board, the first queen will initialize the puzzle by selecting a slot on the board and then notifying the \textit{next} queen to indicate that it is its turn to select a slot. If a queen finds a safe slot and there is no queen left that have'nt selected a slot, the puzzle is solved. Further more if a \texttt{QueenAgent} fails to find a safe slot on the board it will notify the \textit{preceeding} agent about this and ask it to change its slot on the board. If an agent fails to find a safe slot on the board that have'nt already been tried and there is no preceeding queen to notify, the puzzle is considered unsolvable. In order for the queens to find each other they register at the \texttt{DirectoryFacilitator} (DF).
\subsection*{Mobile Agents}
\subsubsection*{Agent Design}
The \texttt{CuratorAgent} and \texttt{ArtistManagerAgent} in this scenario uses the same behaviours as for Homework2 with a few modifications:
\begin{itemize}
\item Both agents runs in parallel to their other behaviours, a cyclic behaviour \texttt{ReceiveCommands} that receives commands from a controller agent to do one of the following: $(i)$ move to a container $(ii)$ clone itself $(iii)$ kill itself
\item Both agents use GUI's for interacting with the user and start/stopping auctions rather than the command-line as used in Homework2.
\item The \texttt{ArtistManagerAgent} will run a cyclic behaviour \texttt{ClonesServer} in parallel with other behaviours for receiving auction-results from clones. Consequently, after finnishing an auction, if the \texttt{ArtistManagerAgent} is a clone and has a ``parent''-agent, it will send the result to that agent.
\item Auctions are ran locally on containers, not globally on the platform.
\end{itemize}
In addition to the \texttt{CuratorAgent} and \texttt{ArtistManagerAgent}, a third agent called \texttt{ControllerAgent} is used. The \texttt{ControllerAgent} and associated \texttt{ControllerGUI} is inspired from the example code at the tutorial \citep{jade_tutorial2} that was recommended as a guide for this assignment. The \texttt{ControllerAgent} creates containers as well as agents and issues commands to existing agents to move, clone or die. The \texttt{ControllerAgent} communicates with the user through the \texttt{ControllerGUI}.
\subsubsection*{Society Design}
The dutch auction interactions from Homework2 have been extended for intra-platform mobility where auctions are performed locally on containers instead of globally on platforms. Further more the results of auctions are forwarded by clones to parent-agents which will synthesize the results and present the best price from its point of view. The interactions between bidders and auctioneers in the actual auction is identical to the interactions presented in Homework2.

ControllerAgent communicates with the \texttt{AgentManagementSystem} (AMS) to retrieve a list of all containers on the platform. The ControllerAgent also communicates with agents that it have created by sending simple one-to-one commands to agents, where no reply is expected. The commands that might be sent from the ControllerAgent to created agents are: clone, move, kill.
\section*{Conclusions}
Extending simple agents to be intra-platform mobile allows for designing agents with further capabilities for acting autonomously. The agents for this homework were limited to mobility within a single platform but the same design principles could be applied for inter-platform mobility if the underlying agent-architecture allows for it.

\section*{Attachments}
Documented source code can be found in the attached zipfile. See README.MD in the root directory for instruction on how to execute and build the program.

\bibliography{references}{}
\bibliographystyle{plain}
\end{document}